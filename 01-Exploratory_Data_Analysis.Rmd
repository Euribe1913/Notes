# Exploratory Data Analysis

**Learning Outcomes:**  

1. Interpret graphical summaries of data, including boxplots, histograms, violin plots, density plots, scatterplots, and correlation plots.    
2. Read data from a .csv file into R.    
3. Preview data in R.   
4. Create graphical summaries of data using R.    
5. Calculate summary statistics for entire datasets and grouped summaries.   
6. Create reproducible documents using R Markdown.  


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 3, fig.width = 7, cache=TRUE)
library(ggformula)
library(moderndive)
library(gridExtra)
library(skimr)
library(Bolstad)
library(GGally)
library(Lock5Data)
library(knitr)
library(caret)
library(MASS)
library(tidyverse)
options(scipen=999)
set.seed(07302020)
```


## Exploring Data Visualizations


### COVID-19 Data

The following data were contained in a UK technical report on the Delta Variant on August 2, 2021

| Vaccination Status      | Deaths  |   Total Cases | Fatality Rate |
| ------- | ------- | ----------| -----|  
| Fully Vax | 402 | 47,008 | 0.86% | 
| Unvax | 253 | 151,054 | 0.17 % | 

```{r, echo=FALSE}
Vac_Status <- c(rep("Fully Vax", 47008), c(rep("Unvax", 151054)))
Outcome <- c(rep("Death", 402), rep("Survival", 47008-402), rep("Death", 253), rep("Survival", 151054-253))
Age <- c(rep("<50", 13), rep(">50", 389), rep("<50", 25536-13), rep(">50", 21472-389), 
         rep("<50", 48), rep(">50", 205), rep("<50", 147614-48), rep(">50", 3440-205))
Covid_Data <- data.frame(Vac_Status, Outcome, Age)
```


```{r}
ggplot(data=Covid_Data, aes(x=Vac_Status, fill=Outcome)) + geom_bar(position="fill")
```

One explanation would be that vaccines don't work, and even cause harm.  

Can you think of another explanation?  


### Vax by Age Breakdown


```{r}
ggplot(data=Covid_Data, aes(x=Vac_Status, fill=Age)) + geom_bar(position="fill") 
```

Since almost all of the unvaccinated people were from the lower risk category, the death rate among unvaccinated people appears lower. 

We should account for age when comparing survival rates.  

### Breakdown by Age < 50

We break down the cases based on whether the patient was older or younger than 50. 

Under 50

| Vaccination Status      | Deaths  |   Total Cases | Fatality Rate |
| ------- | ------- | ----------|------|   
| Fully Vax | 13 | 25,536 | 0.05% | 
| Unvax | 48 | 147, 612 | 0.03 % | 


50 or Older

| Vaccination Status      | Deaths  |   Total Cases | Fatality Rate |
| ------- | ------- | ----------| ----- |   
| Fully Vax | 389 | 21,472 | 1.81% | 
| Unvax | 205 | 3,440 | 5.96 % | 


```{r}
ggplot(data=Covid_Data, aes(x=Vac_Status, fill=Outcome)) + geom_bar(position="fill") + facet_wrap(~Age)
```


Before accounting for age, vaccinated people appear to be 5 times MORE likely to die from covid than unvaccinated people.   

After accounting for age, vaccinated young people appear to be about 1.5 times more likely to die from covid (though death rates are very low) overall, and vaccinated older people appear to be more than 3 times LESS likely.   

This is an example of a statistical phenomenon known as **Simpson's Paradox.**

### Simpson's Paradox

**Simpson's Paradox** refers to a situation where an apparent trend either disappears or reverses when one or more additional variables are accounted for. These additional variables are called **confounding variables.**

In this situation, age is a counfouding variable. Older people are more likely to be vaccinated, and also more likely to die of covid (regardless of vaccination status), thus it appears that vaccinated people are more likely to die from covid, unless we account for age.   

When we build statistical models, it will be important to account for potential confounding variables in our data, otherwise a model will give misleading results.  


Final note: Subsequent data has shown that among people under 50, vaccinated people also had lower death rates (though death rates remained very low for both vaccinated and unvaccinated people). The slightly higher death rate for vaccinated people under 50, seen in these early data, is likely due to young people with other risk conditions being vaccinated first. 

[Data Source](https://www.covid-datascience.com/post/simpson-s-paradox-strikes-again-refuting-reports-vaxxed-have-5x-case-fatality-rate-than-untaxed)


### Exploring Diamond Prices

The following data come from a dataset with information on over 53,940 diamonds. We'll explore the relationship between price (in $ US) and quality of the cut of the diamond (ideal, premium, very good, good, fair." 

```{r, echo=FALSE}
library(tidyverse)
data(diamonds)

diamonds$cut <- factor(x = diamonds$cut, levels = c("Fair",
                                        "Good",
                                        "Very Good",
                                        "Premium",
                                        "Ideal"), ordered = TRUE)
```

Consider the following plots:

```{r}
ggplot(data=diamonds, aes(x=price, y=cut, fill=cut)) + 
  geom_boxplot(outlier.size=0.01, outlier.alpha = 0.1) + 
    stat_summary(fun=mean, geom="point", shape=4, color="red", size=3) + ggtitle("Price by Quality of Cut")
```

Diamonds come in different carat sizes, so we should consider information about that as well. 

We examine a histogram, displaying the number of diamonds with each cut, and carat size.  

```{r}
ggplot(data=diamonds, aes(x=carat, fill=cut)) + geom_histogram() + ggtitle("Diamonds by Carat Size and Cut Quality")
```
The table shows the number of diamonds of each cut, as well as the average carat size and price of each diamond.  


```{r}
diamonds %>% group_by(cut) %>% summarize(N=n(), 
                                         Avg_carat=mean(carat), 
                                         Avg_price=mean(price) ) 

```

Finally, we use a scatterplot to visualize cut, price, and carat size. 

```{r}
ggplot(data=diamonds, aes(x=carat, y=price, color=cut)) + geom_point() + ggtitle("Price by Carat Size and Cut")
```

**Question:**   
How is Simpson's paradox present in the diamonds data? What is the confounding variable? What conclusion should we draw about the relationship between the price of a diamond and the quality of the cut?  


## Exploratory Analysis in R

This section provides examples of how to read data into R, create graphics, like those in the previous section, and calculate summary statistics. 

We'll work with data on movies released in Hollywood between 2012 and 2018.  

### Loading the Data

We'll begin by loading the `tidyverse` package, which can be used to create professional graphics, and wrangle (or manipulate) data into forms that are informative and easy to work with. 

```{r}
library(tidyverse)
```

```{r, echo=FALSE}
select <- dplyr::select
```


Next, we read in the data itself, from the website where it is stored. 

```{r}
HollywoodMovies <- read_csv("https://www.lock5stat.com/datasets3e/HollywoodMovies.csv")
```


### Previewing the Data

**`head()`**

The `head()` function displays the first 5 rows of the dataset. 

```{r}
head(HollywoodMovies)
```


The rows of the dataset are called **observations.** In this case, the observations are the movies.   

The columns of the dataset, which contain information about the movies, are called **variables.**



**`glimpse `**

The `glimpse()` command shows the number of observations (rows), and the number of variables, (columns). We also see the name of each variable and its type. Variable types include 

* **Categorical variables**, which take on groups or categories, rather than numeric values. In R, these might be coded as logical `<logi>`, character `<chr>`, factor `<fct>` and ordered factor `<ord>`.  
  
* **Quantitative variables**, which take on meaningful numeric values. These include numeric `<num>`, integer `<int>`, and double `<dbl>`.   

```{r}
glimpse(HollywoodMovies)
```

There are 1,295 movies in the dataset, and 15 variables for each film.   

**`summary`**

`summary` displays the mean, minimum, first quartile, median, third quartile, and maximum for each numeric variable. 

```{r}
summary(HollywoodMovies)
```

Notice that 239 films have missing information on some of the variables, recorded as NA's. 

### Adding a New Variable 

We can use the `mutate()` function to create a new variable based on variables already in the dataset. 

In the data description, the variable `Profitability` is defined as *WorldGross as a percentage of Budget*. Thus, films for which `Profitability` exceeds 100 were profitable. 

We create a variable to tell whether or not a film was profitable. Note that in R, a variable defined as a condition, such as `Profitability>100` will return values of either `TRUE` or `FALSE`.   

```{r}
HollywoodMovies <- HollywoodMovies %>% mutate(Profitable = Profitability > 100)
```

```{r}
summary(HollywoodMovies$Profitable)
```


### Selecting Columns

If the dataset contains a large number of variables, narrow down to the ones you are interested in working with. This can be done with the `select()` command.  If there are not very many variables to begin with, or you are interested in all of them, then you may skip this step.

Let's narrow the dataset down to the variables `Movie`, `RottenTomatoes`, `AudienceScore`, `Genre`, `WorldGross`, `Budget`, "Profitable", and `Year`.  


```{r}
MoviesSubset <- HollywoodMovies %>% select(Movie, RottenTomatoes, AudienceScore, 
                                           Genre, WorldGross, Budget, Profitable, 
                                           Year)
```


### Filtering by Row

The `filter()` command narrows a dataset down to rows that meet specified conditions.


**Filtering by a Categorical Variable**

Let's filter the data to only include action movies, comedies, dramas, and horror movies. 

We'll also keep only those films whose budget was listed, excluding the 239 NA's. The command `!is.na()` returns only values that are not NA's. 


```{r}
MoviesSubset1 <- MoviesSubset %>% 
  filter(Genre %in% c("Action", "Comedy", "Drama", "Horror")) %>%  filter(!is.na(Budget))
```

In R, the `!` operator means "not". 


```{r}
glimpse(MoviesSubset1)
```

**Filtering by a Quantitative Variable**

Let's filter the data to only include films whose world gross exceeds 100 million dollars. 

```{r}
MoviesSubset2 <- MoviesSubset %>% filter(WorldGross >100)
```

Now, let's preview the data again. 

```{r}
glimpse(MoviesSubset2)
```

We'll use MoviesSubset1 from this point forward. 


### Histogram 

Next, we'll create graphics to help us visualize the distributions and relationships between variables. We'll use the `ggplot()` function, which is part of the `tidyverse` package. 


Histograms are useful for displaying the distribution of a single quantitative variable    

**General Template for Histogram**

```{r, eval=FALSE}
ggplot(data=DatasetName, aes(x=VariableName)) + 
  geom_histogram(fill="colorchoice", color="colorchoice") + 
  ggtitle("Plot Title") +
  xlab("x-axis label") + 
  ylab("y-axis label")
```

**Histogram of Audience Scores**

```{r}
ggplot(data=MoviesSubset1, aes(x=AudienceScore)) + 
  geom_histogram(fill="lightblue", color="white") + 
  ggtitle("Distribution of Audience Scores") +
  xlab("Audience Score") + 
  ylab("Frequency")
```

### Density Plots

Density plots show the distribution for a quantitative variable like audience score. Scores can be compared across categories, like genre.   

**General Template for Density Plot**

```{r, eval=FALSE}
ggplot(data=DatasetName, aes(x=QuantitativeVariable,
                             color=CategoricalVariable, fill=CategoricalVariable)) + 
  geom_density(alpha=0.2) + 
  ggtitle("Plot Title") +
  xlab("Axis Label") + 
  ylab("Frequency") 
```

`alpha`, ranging from 0 to 1 dictates transparency. 

**Density Plot of Audience Scores**

```{r}
ggplot(data=MoviesSubset1, aes(x=AudienceScore, color=Genre, fill=Genre)) + 
  geom_density(alpha=0.2) + 
  ggtitle("Distribution of Audience Scores") +
  xlab("Audience Score") + 
  ylab("Frequency") 
```

###  Boxplot

Boxplots can be used to compare a quantitative variable with a categorical variable

**General Template for Boxplot**

```{r, eval=FALSE}
ggplot(data=DatasetName, aes(x=CategoricalVariable, 
                             y=QuantitativeVariable)) + 
  geom_boxplot() + 
  ggtitle("Plot Title") + 
  xlab("Variable Name") + ylab("Variable Name") 
```

You can make the plot horizontal by adding `+ coordflip()`. You can turn the axis text vertical by adding `theme(axis.text.x = element_text(angle = 90))`. 

**Boxplot Comparing Scores for Genres**

```{r}
ggplot(data=MoviesSubset1, aes(x=Genre, y=AudienceScore)) + geom_boxplot() + 
  ggtitle("Audience Score by Genre") + 
  xlab("Genre") + ylab("Audience Score") + 
  theme(axis.text.x = element_text(angle = 90))
```

### Violin Plot

Violin plots are an alternative to boxplots. The width of the violin tells us the density of observations in a given range. 

**General Template for Violin Plot**

```{r, eval=FALSE}
ggplot(data=DatasetName, aes(x=CategoricalVariable, y=QuantitativeVariable, 
                             fill=CategoricalVariable)) + 
  geom_violin() + 
  ggtitle("Plot Title") + 
  xlab("Variable Name") + ylab("Variable Name") 
```

**Violin Plot Comparing Scores for Genres**

```{r}
ggplot(data=MoviesSubset1, aes(x=Genre, y=AudienceScore, fill=Genre)) + 
  geom_violin() + 
  ggtitle("Audience Score by Genre") + 
  xlab("Genre") + ylab("Audience Score") + 
  theme(axis.text.x = element_text(angle = 90))
```

We can view the boxplot and violin plot together. 

### Scatterplots   

Scatterplots are used to visualize the relationship between two quantitative variables.  

**Scatterplot Template**

```{r, eval=FALSE}
ggplot(data=DatasetName, aes(x=CategoricalVariable, y=QuantitativeVariable)) + 
  geom_point() +
  ggtitle("Plot Title") + 
  ylab("Axis Label") + 
  xlab("Axis Label")
```


**Scatterplot Comparing Audience Score and Rotten Tomatoes Score**

```{r}
ggplot(data=MoviesSubset1, aes(x=RottenTomatoes, y=AudienceScore)) + 
  geom_point() +
  ggtitle("Audience and Critics Ratings") + 
  ylab("Audience Rating") + 
  xlab("Critics' Rating")
```

We see that there is an upward trend, indicating a positive association between critics scores (RottenTomatoes), and audience scores. However, there is a lot of variability, and the relationship is moderately strong at best.   

We can also add color, size, and shape to the scatterplot to display information about other variables. 

```{r}
ggplot(data=MoviesSubset1, 
       aes(x=RottenTomatoes, y=AudienceScore, color=Genre, size=WorldGross)) + 
  geom_point() +
  ggtitle("Audience and Critics Ratings") + 
  ylab("Audience Rating") + 
  xlab("Critics' Rating")
```

We can add labels for points meeting certain conditions, using `geom_text()`. This should be done carefully, to avoid overlap. 

```{r}
ggplot(data=MoviesSubset1, 
       aes(x=RottenTomatoes, y=AudienceScore, color=Genre, size=WorldGross)) + 
  geom_point() +
  ggtitle("Audience and Critics Ratings") + 
  ylab("Audience Rating") + xlab("Critics' Rating") + 
  geom_text(data = MoviesSubset1 %>% filter(WorldGross >800), aes(label = Movie), 
            color="black", check_overlap = TRUE)
```

### Bar Graphs  

Bar graphs can be used to visualize one or more categorical variables 


**Bar Graph Template**

```{r, eval=FALSE}
ggplot(data=DatasetName, aes(x=CategoricalVariable)) + 
  geom_bar(fill="colorchoice",color="colorchoice")  + 
  ggtitle("Plot Title") + 
  xlab("Variable Name") + 
  ylab("Frequency") 
```

**Bar Graph by Genre**

```{r}
ggplot(data=MoviesSubset1, aes(x=Genre)) + 
  geom_bar(fill="lightblue",color="white")  + 
  ggtitle("Number of Films by Genre") + 
  xlab("Genre") + 
  ylab("Number of Films") +   
  theme(axis.text.x = element_text(angle = 90))
```

### Stacked and Side-by-Side Bar Graphs

**Stacked Bar Graph Template**

```{r, eval=FALSE}
ggplot(data = DatasetName, mapping = aes(x = CategoricalVariable1, 
                                         fill = CategoricalVariable2)) +
    stat_count(position="fill")  +
  theme_bw() + ggtitle("Plot Title") + 
  xlab("Variable 1") + 
  ylab("Proportion of Variable 2") +   
  theme(axis.text.x = element_text(angle = 90)) 
```


**Stacked Bar Graph Example**

The `stat_count(position="fill")` command creates a stacked bar graph, comparing two categorical variables.  Let's explore whether certain genres are more profitable than others, using the profitability variable. 

```{r}
ggplot(data = MoviesSubset1, mapping = aes(x = Genre, fill = Profitable)) +
    stat_count(position="fill")  +
  theme_bw() + ggtitle("Profitability by Genre") + 
  xlab("Genre") + 
  ylab("Proportion Profitable") +   
  theme(axis.text.x = element_text(angle = 90)) 
```


**Side-by-side Bar Graph Template**

We can create a side-by-side bar graph, using `position=dodge`. 

```{r, eval=FALSE}
ggplot(data = DatasetName, mapping = aes(x = CategoricalVariable1, 
                                         fill = CategoricalVariable2)) +
    geom_bar(position = "dodge") +
  ggtitle("Plot Title") + 
  xlab("Genre") + 
  ylab("Frequency") 
```

**Side-by-side Bar Graph Example**

```{r}
ggplot(data = MoviesSubset1, mapping = aes(x = Genre, fill = Profitable)) +
    geom_bar(position = "dodge") +
  ggtitle("Number of Films by Genre") + 
  xlab("Genre") + 
  ylab("Number of Films") +   
  theme(axis.text.x = element_text(angle = 90)) 
```


### Correlation Plot

Correlation plots can be used to visualize relationships between quantitative variables. These can be helpful when we proceed to modeling. Explanatory variables that are highly correlated with the response are often strong predictors that should be included in a model. However, including two explanatory variables that are highly correlated with one another can create interpretation problems. 

The `cor()` function calculates correlations between quantitative variables. We'll use `select_if` to select only numeric variables. The `use="complete.obs" command tells R to ignore observations with missing data. 


```{r}
cor(select_if(HollywoodMovies, is.numeric), use="complete.obs") %>% round(2)
```


The `corrplot()` function in the `corrplot()` package provides a visualization of the correlations. Larger, thicker circles indicate stronger correlations. 


```{r, fig.height=12, fig.width=12}
library(corrplot)
Corr <- cor(select_if(HollywoodMovies, is.numeric), use="complete.obs")
corrplot(Corr)
```

We can also display a numeric version of the correlations by setting `method="number"`. 

```{r, fig.height=12, fig.width=12}
Corr <- cor(select_if(HollywoodMovies, is.numeric), use="complete.obs")
corrplot(Corr, method="number")
```



### Scatterplot Matrix

A scatterplot matrix is a grid of plots. It can be created using the `ggpairs()` function in the `GGally` package. 

The scatterplot matrix shows us:  

1. Along the diagonal are density plots for quantitative variables, or bar graphs for categorical variables, showing the distribution of each variable.   
2. Under the diagonal are plots showing the relationships between the variables in the corresponding row and column. Scatterplots are used when both variables are quantitative, bar graphs are used when both variables are categorical, and boxplots are used when one variable is categorical, and the other is quantitative.    
3. Above the diagonal are correlations between quantitative variables. 

We need to remove the column with the movie names. This is done using `select`. 


```{r, fig.height=12, fig.width=12}
library(GGally)
ggpairs(MoviesSubset1 %>% select(-Movie))
```

The scatterplot matrix is useful for helping us notice key trends in our data. However, the plot can hard to read as it is quite dense, especially when there are a large number of variables. These can help us look for trends from a distance, but we should then focus in on more specific plots. 

### Summary Tables

**`group_by()` and `summarize()`**


The `group_by()` and `summarize()` commands are useful for breaking categorical variables down by category. For example, let's calculate number of films in each genre, and the mean,  median, and standard deviation in film `WorldGross` by genre. 

```{r}
MoviesSubset1 %>% group_by(Genre) %>%
  summarize(N = n(), 
            Mean_Gross = mean(WorldGross, na.rm=TRUE), 
            Median_Gross = median(WorldGross, na.rm=TRUE), 
            StDev_Gross = sd(WorldGross, na.rm = TRUE)) %>%
  arrange(desc(Mean_Gross))
```

Notes:  
1. The `n()` command calculates the number of observations in a category.    
2. The `na.rm=TRUE` command removes missing values, so that summary statistics can be calculated.  
3. `arrange(desc(Mean_Gross))` arranges the table in descending order of Mean_Gross. To arrange in ascending order, use `arrange(Mean_Gross)`. 


The `kable()` function in the `knitr()` package creates tables with professional appearance. 

```{r}
library(knitr)
MoviesTable <- MoviesSubset1 %>% group_by(Genre) %>%
  summarize(N = n(), 
            Mean_Gross = mean(WorldGross, na.rm=TRUE), 
            Median_Gross = median(WorldGross, na.rm=TRUE), 
            StDev_Gross = sd(WorldGross, na.rm = TRUE)) %>%
  arrange(desc(Mean_Gross))
kable(MoviesTable)
```


